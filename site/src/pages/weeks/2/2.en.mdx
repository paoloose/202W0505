---
title: 'Assignment 2: Ranked Choice Voting'
description: 'Building Java Programs Chapter 10: ArrayList. Study Case.'
img: ''
---

import Snippet from '@components/Snippet.astro';
import WeekLayout from '@layouts/WeekLayout.astro';

<WeekLayout h1_title='Chapter 10 Study Case: Ranked Choice Voting'>

    # Introduction

    When considering data structures and algorithms, it is essential to recognize that their abstraction extends beyond computational areas. In fact, society itself has demonstrated the significant impact of these abstract concepts by applying them to various spheres, including voting systems. In the United States, Ranked Choice Voting, also known as instant-runoff voting, has gained prominence as a voting system where voters rank candidates in order of preference. Let's briefly explore how this system works:

    To simplify things, let's use the candidates A, B, C, and D. Here is a list of voting preferences:

    <Snippet file='votes1.txt'/>

    In the traditional voting procedure, the first choice of each voter is counted. In this case, candidate A receives three votes, which is 37.5% of the total eight votes. However, no candidate has a clear majority. In ranked choice voting, the candidate with the lowest vote total (candidate D) is eliminated. The preferences are then updated:

    <Snippet file='votes2.txt'/>

    Still, no candidate has a majority, so the candidate with the lowest vote total (candidate B) is eliminated. The preferences are updated again:

    <Snippet file='votes3.txt'/>

    Now, candidate C has five votes and wins the election. It is important to note that in the first round of voting, candidate C was tied for second place. However, more voters preferred candidate C as a substitute if they couldn't get their preferred candidates.

    We will develop a program that implements the ranked choice voting algorithm using `ArrayList` in Java. The program will be developed in stages:


    # The Ballot Class

    We considered appropiate to define the preferences of a single voter as a "ballot," and the collection of all ballots. We decided to list each voter's preferences as a single line of data with the candidates listed from most to least desirable, each separated with a tab character, making it easier to break up such a string into an array of strings. That's why the constructor will take an array of strings as a parameter:

    <Snippet file='Ballot.java' line_start={7} line_end={7}/>

    Due to the need of storing and eliminating candidates in every round, a dynamic data structure such as an `ArrayList` is suitable for this task.

    <Snippet file='Ballot.java' line_start={4} line_end={12}/>

    Now, we provided a list of important behaviours for the class:
    - Method that returns the current top choice of a voter, which will always be the first element of your list (`index 0`).

    <Snippet file='Ballot.java' line_start={14} line_end={20}/>

    - Eliminate a candidate from consideration. The `ArrayList` comes in handy for this because you can simply call its `remove` method to remove a value:

    <Snippet file='Ballot.java' line_start={22} line_end={24}/>

    ### The Comparable Interface

    - To make it easier to count votes, we sort the list of ballots by candidate name. That way all of the votes for a given candidate will be grouped together. That means the `Ballot` class must implement the `Comparable interface`. The names are stored as strings and the `String class` implements `Comparable`, leaving us with the possibility to use the `compareTo` method to perform this comparison:

    <Snippet file='Ballot.java' line_start={30} line_end={33}/>

    # Counting Votes

    Now that the Ballot is represented, we can move forward to writing the overall program in a separate file called `CountVotes.java`. We stored the votes in a file called `votes.txt`. The program is supposed to read the information from this file to create an `ArrayList` of Ballot objects. You can then sort the list by candidate name and count the votes by calling the `Collections.sort`. Also, by the return of a boolean in the `oneRound` method we know whether or not the voting has ended. We added some code for reporting the round number. That leads to the following main method:

    <Snippet file='CountVotes.java' line_start={4} line_end={17}/>

    The reading and vote counting operations deserve to be written as methods.
    - `readFile`: involves reading the input file line by line and adding Ballot objects to an `ArrayList`. The Ballot constructor expects an array of strings to specify the candidate choice. The String class has a method called split that provides a convenient way to break up this string into the individual names. It takes a parameter that specifies what separator or delimiter to use.

    <Snippet file='CountVotes.java' line_start={19} line_end={28}/>

    - `oneRound`: involves counting the votes for each candidate and determining if there is a winner. If there is no winner, the candidate with the fewest votes is eliminated. The method returns a boolean value that indicates whether the voting has ended.
    There are three possible outcomes. If the count for the top candidate is more than 50%, then that candidate has won. Otherwise, you would normally eliminate the candidate with the lowest vote total. However, there is one special case to consider. When there are only two candidates remaining and they both earn exactly 50% of the vote, there is no winner and the algorithm should stop.

    <Snippet file='CountVotes.java' line_start={30} line_end={72}/>

    ### Incomplete preferences
    Voters are normally allowed to fill out the ballot in an incomplete manner. For example, with the sample ballots with four candidates, you might have ballots that specify only a first choice or only two choices. When you have partial information, you can end up with empty ballots because the voter might have chosen candidates who are all eliminated.

    <Snippet file='votes_incomplete.txt' />

    After the first round, the D candidate would be eliminated. As it is the only voter's preference, the ballot will be left empty. The program should be able to remove the empty ballot for the next round and modify the percentages of the votes, considering that the total number of ballots is changing.

    The `isEmpty` method implemented in `Ballot.java` will indicate that there are no candidates left.

    <Snippet file='Ballot.java' line_start={26} line_end={28}/>

    Moving onto the `CountVotes` program, it was necessary to include a method that eliminates candidates but also removes from the list of ballots any ballots that become empty. That way the percentages will be reported correctly on the next round of tallying.

    <Snippet file='CountVotes.java' line_start={74} line_end={83}/>

    ### Handling Ties
    In the `oneRound` method, we handle ties by stopping the algorithm if there's a tie between remaining candidates where each of them earns exactly 50% of the vote.

    <Snippet file='CountVotes.java' line_start={59} line_end={61}/>

    Still, a new challenge arises in situations where there are multiple remaining candidates with the same number of votes in rounds after the first one. In such cases, it is necessary to eliminate one candidate to avoid a tie.

    After conducting research, we discovered that the ranked choice voting system has many tie-breaking rules to choose from. For example, the candidate with the fewest first-choice votes can be eliminated. If there is a tie for the fewest first-choice votes, the candidate with the fewest second-choice votes is eliminated, and so on.

    <Snippet file='votes_tie.txt'/>

    We realised that the previous rule wouldn't work in this case, because in the previous and only round, the two lower candidates, A and B, also had the same number of votes. We decided to implement other rule: if there is a tie in the minimum number of votes between two or more candidates in a round, the algorithm will eliminate one of those candidates based on the order in which they appear in the input data, since in the "while" loop the votes are reviewed in that order.

    <Snippet file='CountVotes.java' line_start={30} line_end={30}/>
    <Snippet file='CountVotes.java' line_start={50} line_end={53}/>
    <Snippet file='CountVotes.java' line_start={67} line_end={71}/>

    # Conclusion

    The Ballot Class should look like following:
    <Snippet file='Ballot.java' />

    Putting pieces together, you get the following complete program for counting votes:
    <Snippet file='CountVotes.java' />

</WeekLayout>
