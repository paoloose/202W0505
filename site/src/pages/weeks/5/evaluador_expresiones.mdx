import Snippet from '@components/Snippet.astro';
import FileButton from '@components/FileButton.astro';
import Dialog from '@components/Dialog.astro';
import Link from '@components/Link.astro';
import WeekLayout from '@layouts/WeekLayout.astro';

<WeekLayout h1_title='Estudio de Caso: Evaluador de Expresiones' main_id='#logic-parser'>
  <Dialog title='Problema Propuesto'>
    Modifique el programa del estudio de caso discutido para crear un nuevo programa que acepte como entrada una expresión infija con paréntesis y devuelva una cadena que represente una expresión postfija equivalente. Las expresiones Posfija son aquellas en las que cada operador sigue sus dos operandos, como 1 2 + en lugar de 1 + 2. Las expresiones Postfija son elegantes porque no necesitan paréntesis. Por ejemplo, la expresión infija dada:

    `(9 + (8 * 7 - (6/5 ^ 4) * 3) * 2)`

es equivalente a la siguiente expresión postfija:

    `9 8 7 * 6 5 4 ^ / 3 * - 2 * + `

Su algoritmo debe leer la expresión token por token, utilizando una pila para almacenar operadores. (Ya no necesita la pila de valores del estudio de caso original). En su lugar, cada vez que encuentre un número, agréguelo a una cadena que esté creando. Cada vez que encuentre un paréntesis derecho, abra la pila para obtener un operador y agréguelo a la cadena que está creando. Deje el resto del código en su lugar para preservar la verificación de errores. Devuelva la cadena "expresión ilegal" si se encuentra un error.
  </Dialog>

  #### Desarrollo

  Comenzamos creando un mapa, que nos permitirá asignar un valor numérico a cada operador, para poder comparar su precedencia.

  <Snippet key={'tab-3'} label={'Rust'} lang={'rust'} file='rust/evaluador_expresiones/src/main.rs' line_start={6} line_end={14} />

  Para evitar errores o cualquier dificultad al momento de evaluar la expresión, utilizamos una función para eliminar los espacios en blanco.

  <Snippet key={'tab-3'} label={'Rust'} lang={'rust'} file='rust/evaluador_expresiones/src/main.rs' line_start={54} line_end={56} />

  Luego, debido a que un string no es iterable en rust, pasamos todos los caracteres de la expresión a un vector de caracteres.

  <Snippet key={'tab-3'} label={'Rust'} lang={'rust'} file='rust/evaluador_expresiones/src/main.rs' line_start={16} line_end={23} />

  Ahora, pasamos a recorrer el vector de caracteres, y dependiendo de si el caracter es un número, un operador o un paréntesis, realizamos las operaciones correspondientes.
  Si es un número, lo agregamos a la cadena de salida. Si es un operador o paréntesis, llamamos a la función postfija.

  <Snippet key={'tab-3'} label={'Rust'} lang={'rust'} file='rust/evaluador_expresiones/src/main.rs' line_start={25} line_end={34} />

  Nuestra función postfija, se encarga de controlar la precedencia de los operadores en la pila, y de agregarlos a la cadena de salida.

  <Snippet key={'tab-3'} label={'Rust'} lang={'rust'} file='rust/evaluador_expresiones/src/infija_to_postfija/postfija.rs' line_start={5} line_end={37} />

  Una vez se ha recorrido todos los caracteres de la expresión, utilizamos la función pop_everything para vaciar la pila y agregar los operadores restantes a la cadena de salida.

  <Snippet key={'tab-3'} label={'Rust'} lang={'rust'} file='rust/evaluador_expresiones/src/main.rs' line_start={36} line_end={37} />
  <Snippet key={'tab-3'} label={'Rust'} lang={'rust'} file='rust/evaluador_expresiones/src/infija_to_postfija/postfija.rs' line_start={39} line_end={45} />
  <Link back>Go back</Link>

</WeekLayout>

